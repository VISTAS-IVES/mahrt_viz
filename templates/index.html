<!DOCTYPE html>
<html>
	<head>
		<title>Larry Mahrt Viz</title>
		<style>
			body { margin: 0; height: 100vh; overflow-y:hidden; }
			canvas { width: 100%; height: 100%}
		</style>
	</head>
	<body>
		<script type="x-shader/x-vertex" id="vertexShader">

			// Vertex Shader
			/*
				Vertex shaders consume information per vertex specified in this shader program's attribute arrays.

				Typical vertex shaders contain position, normal (shading), and index data. Ultimately we have to specify a vec4 object with position information by filling the built-in
				gl_Position value.

				We also can pass information to the fragment shader on a per-vertex basis, such as
				texture coordinates (or 'uv' coordinates).

				Uniform variables are applyed across every vertex for the shader program,
				while attribute variables supply the per-vertex information.
			*/

			// *** Note: attribute variables are inherited from the THREE WebGLProgram creation process
			//
			// Attributes included from THREE.WebGLProgram include:
			// attribute vec3 position;
			// attribute vec2 uv;

			// declare uniform variables specified in the shader program (i.e. uniform locations)
			//uniform sampler2D t_normal;

			varying vec2 vUV;
			//varying vec3 fN;
			//varying vec3 fE;
			//varying vec3 fL;

			void main()
			{
				// Copy the uv coordinates from the 'uv' attribute to the fragment shader
				vUV = uv;

				// Sample normal texture for hill shading.
				//fN = normalize(texture2D(t_normal, uv).xyz * 256.);
                //fE = -(modelViewMatrix * vec4(position, 1.0)).xyz;

				// Set the light position. Make it a unit vector since direction is what matters.
				//fL = normalize(vec3(1.0,-1.0,1.0));

				// Set the final position of this vertex in MVP coordinates
			    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentShader">

			// Fragment Shader
			/*
				Fragment shaders determine the final pixel color, where we can determine shading influences
				from normal vectors, texture data, color attributes inherited from the vertex shader, etc.

				We can call the builtin 'discard' function whenever we find conditions we don't want to show.
				This can be expensive since we wait until the last possible operation to do so, but in GPU memory, discards are cheap.

				The last action that is done is specifying 'gl_FragColor', a vec4 that specifies the RGBA of the pixel.
			*/

			uniform sampler2D t_data;
			varying vec2 vUV;
			//varying vec3 fN;
			//varying vec3 fE;
			//varying vec3 fL;
			//varying float isocean;

			void main()
			{
				// constant ambient, diffuse and specular and shiny values
				//float KA = 0.2;
				//float KD = 1.0;
				//float KS = 0.15;
				//float SHINY = 20.0;

				// sample the layer data
				vec4 texColor = texture2D(t_data, vUV);

				// compute lighting per vertex
				//vec3 N = normalize(fN);
			    //vec3 E = normalize(fE);
			    //vec3 L = normalize(fL);
			    //vec3 H = normalize( L + E );
			    //vec4 ambient = vec4(vec3(KA),1.0)*texColor;
			    //float diffDot = max(dot(L, N), 0.0);
			    //vec4 diffuse = diffDot*vec4(vec3(KD),1.0)*texColor;
			    //float specDot = pow(max(dot(N, H), 0.0), SHINY);
			    //vec4 specular = specDot*vec4(vec3(KS),1.0)*texColor;

			    // zero the specular highlight if the light is behind the vertex being drawn
			    //if( dot(L, N) < 0.0 ) {
				//   specular = vec4(0.0, 0.0, 0.0, 1.0);
			    //}

			    // final pixel color summation from lighting components
			    //vec4 finalColor = ambient + diffuse + specular;
			    //finalColor.a = 1.0;
				//gl_FragColor = finalColor;
				gl_FragColor = texColor;

			}
		</script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/app.js"></script>
	</body>
</html>
